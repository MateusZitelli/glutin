initSidebarItems({"enum":[["WaylandProtocolEvent","An event generated by the protocol wayland.Each variant is composed of a `ProxyId` reffering to the proxy object and of the event data itself."],["WlBufferEvent",""],["WlCallbackEvent",""],["WlDataDeviceEvent",""],["WlDataOfferEvent",""],["WlDataSourceEvent",""],["WlDisplayEvent",""],["WlKeyboardEvent",""],["WlKeyboardKeyState","physical key stateDescribes the physical state of a key which provoked the key event."],["WlKeyboardKeymapFormat","keyboard mapping formatThis specifies the format of the keymap provided to the client with the wl_keyboard.keymap event."],["WlOutputEvent",""],["WlOutputSubpixel","subpixel geometry informationThis enumeration describes how the physical pixels on an output are laid out."],["WlOutputTransform","transform from framebuffer to outputThis describes the transform that a compositor will apply to a surface to compensate for the rotation or mirroring of an output device.The flipped values correspond to an initial flip around a vertical axis followed by rotation.The purpose is mainly to allow clients render accordingly and tell the compositor, so that for fullscreen surfaces, the compositor will still be able to scan out directly from client surfaces."],["WlPointerAxis","axis typesDescribes the axis types of scroll events."],["WlPointerButtonState","physical button stateDescribes the physical state of a button which provoked the button event."],["WlPointerEvent",""],["WlRegistryEvent",""],["WlSeatEvent",""],["WlShellSurfaceEvent",""],["WlShellSurfaceFullscreenMethod","different method to set the surface fullscreenHints to indicate to the compositor how to deal with a conflict between the dimensions of the surface and the dimensions of the output. The compositor is free to ignore this parameter."],["WlShmEvent",""],["WlShmFormat","pixel formatsThis describes the memory layout of an individual pixel.All renderers should support argb8888 and xrgb8888 but any other formats are optional and may not be supported by the particular renderer in use."],["WlSurfaceEvent",""],["WlTouchEvent",""]],"mod":[["WlOutputMode","mode informationThese flags describe properties of an output mode. They are used in the flags bitfield of the mode event."],["WlSeatCapability","seat capability bitmaskThis is a bitmask of capabilities this seat has; if a member is set, then it is present on the seat."],["WlShellSurfaceResize","edge values for resizingThese values are used to indicate which edge of a surface is being dragged in a resize operation. The server may use this information to adapt its behavior, e.g. choose an appropriate cursor image."],["WlShellSurfaceTransient","details of transient behaviourThese flags specify details of the expected behaviour of transient surfaces. Used in the set_transient request."]],"struct":[["WlBuffer","content for a wl_surfaceA buffer provides the content for a wl_surface. Buffers are created through factory interfaces such as wl_drm, wl_shm or similar. It has a width and a height and can be attached to a wl_surface, but the mechanism by which a client provides and updates the contents is defined by the buffer factory interface."],["WlCallback","callback objectClients can handle the 'done' event to get notified when the related request is done."],["WlCompositor","the compositor singletonA compositor.  This object is a singleton global.  The compositor is in charge of combining the contents of multiple surfaces into one displayable output."],["WlDataDevice","data transfer deviceThere is one wl_data_device per seat which can be obtained from the global wl_data_device_manager singleton.A wl_data_device provides access to inter-client data transfer mechanisms such as copy-and-paste and drag-and-drop."],["WlDataDeviceManager","data transfer interfaceThe wl_data_device_manager is a singleton global object that provides access to inter-client data transfer mechanisms such as copy-and-paste and drag-and-drop.  These mechanisms are tied to a wl_seat and this interface lets a client get a wl_data_device corresponding to a wl_seat."],["WlDataOffer","offer to transfer dataA wl_data_offer represents a piece of data offered for transfer by another client (the source client).  It is used by the copy-and-paste and drag-and-drop mechanisms.  The offer describes the different mime types that the data can be converted to and provides the mechanism for transferring the data directly from the source client."],["WlDataSource","offer to transfer dataThe wl_data_source object is the source side of a wl_data_offer. It is created by the source client in a data transfer and provides a way to describe the offered data and a way to respond to requests to transfer the data."],["WlDisplay","core global objectThe core global object.  This is a special singleton object.  It is used for internal Wayland protocol features."],["WlKeyboard","keyboard input deviceThe wl_keyboard interface represents one or more keyboards associated with a seat."],["WlOutput","compositor output regionAn output describes part of the compositor geometry.  The compositor works in the 'compositor coordinate system' and an output corresponds to rectangular area in that space that is actually visible.  This typically corresponds to a monitor that displays part of the compositor space.  This object is published as global during start up, or when a monitor is hotplugged."],["WlPointer","pointer input deviceThe wl_pointer interface represents one or more input devices, such as mice, which control the pointer location and pointer_focus of a seat.The wl_pointer interface generates motion, enter and leave events for the surfaces that the pointer is located over, and button and axis events for button presses, button releases and scrolling."],["WlRegion","region interfaceA region object describes an area.Region objects are used to describe the opaque and input regions of a surface."],["WlRegistry","global registry objectThe global registry object.  The server has a number of global objects that are available to all clients.  These objects typically represent an actual object in the server (for example, an input device) or they are singleton objects that provide extension functionality.When a client creates a registry object, the registry object will emit a global event for each global currently in the registry.  Globals come and go as a result of device or monitor hotplugs, reconfiguration or other events, and the registry will send out global and global_remove events to keep the client up to date with the changes.  To mark the end of the initial burst of events, the client can use the wl_display.sync request immediately after calling wl_display.get_registry.A client can bind to a global object by using the bind request.  This creates a client-side handle that lets the object emit events to the client and lets the client invoke requests on the object."],["WlSeat","group of input devicesA seat is a group of keyboards, pointer and touch devices. This object is published as a global during start up, or when such a device is hot plugged.  A seat typically has a pointer and maintains a keyboard focus and a pointer focus."],["WlShell","create desktop-style surfacesThis interface is implemented by servers that provide desktop-style user interfaces.It allows clients to associate a wl_shell_surface with a basic surface."],["WlShellSurface","desktop-style metadata interfaceAn interface that may be implemented by a wl_surface, for implementations that provide a desktop-style user interface.It provides requests to treat surfaces like toplevel, fullscreen or popup windows, move, resize or maximize them, associate metadata like title and class, etc.On the server side the object is automatically destroyed when the related wl_surface is destroyed.  On client side, wl_shell_surface_destroy() must be called before destroying the wl_surface object."],["WlShm","shared memory supportA global singleton object that provides support for shared memory.Clients can create wl_shm_pool objects using the create_pool request.At connection setup time, the wl_shm object emits one or more format events to inform clients about the valid pixel formats that can be used for buffers."],["WlShmPool","a shared memory poolThe wl_shm_pool object encapsulates a piece of memory shared between the compositor and client.  Through the wl_shm_pool object, the client can allocate shared memory wl_buffer objects. All objects created through the same pool share the same underlying mapped memory. Reusing the mapped memory avoids the setup/teardown overhead and is useful when interactively resizing a surface or for many small buffers."],["WlSubcompositor","sub-surface compositingThe global interface exposing sub-surface compositing capabilities. A wl_surface, that has sub-surfaces associated, is called the parent surface. Sub-surfaces can be arbitrarily nested and create a tree of sub-surfaces.The root surface in a tree of sub-surfaces is the main surface. The main surface cannot be a sub-surface, because sub-surfaces must always have a parent.A main surface with its sub-surfaces forms a (compound) window. For window management purposes, this set of wl_surface objects is to be considered as a single window, and it should also behave as such.The aim of sub-surfaces is to offload some of the compositing work within a window from clients to the compositor. A prime example is a video player with decorations and video in separate wl_surface objects. This should allow the compositor to pass YUV video buffer processing to dedicated overlay hardware when possible."],["WlSubsurface","sub-surface interface to a wl_surfaceAn additional interface to a wl_surface object, which has been made a sub-surface. A sub-surface has one parent surface. A sub-surface's size and position are not limited to that of the parent. Particularly, a sub-surface is not automatically clipped to its parent's area.A sub-surface becomes mapped, when a non-NULL wl_buffer is applied and the parent surface is mapped. The order of which one happens first is irrelevant. A sub-surface is hidden if the parent becomes hidden, or if a NULL wl_buffer is applied. These rules apply recursively through the tree of surfaces.The behaviour of wl_surface.commit request on a sub-surface depends on the sub-surface's mode. The possible modes are synchronized and desynchronized, see methods wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized mode caches the wl_surface state to be applied when the parent's state gets applied, and desynchronized mode applies the pending wl_surface state directly. A sub-surface is initially in the synchronized mode.Sub-surfaces have also other kind of state, which is managed by wl_subsurface requests, as opposed to wl_surface requests. This state includes the sub-surface position relative to the parent surface (wl_subsurface.set_position), and the stacking order of the parent and its sub-surfaces (wl_subsurface.place_above and .place_below). This state is applied when the parent surface's wl_surface state is applied, regardless of the sub-surface's mode. As the exception, set_sync and set_desync are effective immediately.The main surface can be thought to be always in desynchronized mode, since it does not have a parent in the sub-surfaces sense.Even if a sub-surface is in desynchronized mode, it will behave as in synchronized mode, if its parent surface behaves as in synchronized mode. This rule is applied recursively throughout the tree of surfaces. This means, that one can set a sub-surface into synchronized mode, and then assume that all its child and grand-child sub-surfaces are synchronized, too, without explicitly setting them.If the wl_surface associated with the wl_subsurface is destroyed, the wl_subsurface object becomes inert. Note, that destroying either object takes effect immediately. If you need to synchronize the removal of a sub-surface to the parent surface update, unmap the sub-surface first by attaching a NULL wl_buffer, update parent, and then destroy the sub-surface.If the parent wl_surface object is destroyed, the sub-surface is unmapped."],["WlSurface","an onscreen surfaceA surface is a rectangular area that is displayed on the screen. It has a location, size and pixel contents.The size of a surface (and relative positions on it) is described in surface local coordinates, which may differ from the buffer local coordinates of the pixel content, in case a buffer_transform or a buffer_scale is used.A surface without a \"role\" is fairly useless, a compositor does not know where, when or how to present it. The role is the purpose of a wl_surface. Examples of roles are a cursor for a pointer (as set by wl_pointer.set_cursor), a drag icon (wl_data_device.start_drag), a sub-surface (wl_subcompositor.get_subsurface), and a window as defined by a shell protocol (e.g. wl_shell.get_shell_surface).A surface can have only one role at a time. Initially a wl_surface does not have a role. Once a wl_surface is given a role, it is set permanently for the whole lifetime of the wl_surface object. Giving the current role again is allowed, unless explicitly forbidden by the relevant interface specification.Surface roles are given by requests in other interfaces such as wl_pointer.set_cursor. The request should explicitly mention that this request gives a role to a wl_surface. Often, this request also creates a new protocol object that represents the role and adds additional functionality to wl_surface. When a client wants to destroy a wl_surface, they must destroy this 'role object' before the wl_surface.Destroying the role object does not remove the role from the wl_surface, but it may stop the wl_surface from \"playing the role\". For instance, if a wl_subsurface object is destroyed, the wl_surface it was created for will be unmapped and forget its position and z-order. It is allowed to create a wl_subsurface for the same wl_surface again, but it is not allowed to use the wl_surface as a cursor (cursor is a different role than sub-surface, and role switching is not allowed)."],["WlTouch","touchscreen input deviceThe wl_touch interface represents a touchscreen associated with a seat.Touch interactions can consist of one or more contacts. For each contact, a series of events is generated, starting with a down event, followed by zero or more motion events, and ending with an up event. Events relating to the same contact point can be identified by the ID of the sequence."]]});